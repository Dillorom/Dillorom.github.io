---
layout: post
title:      "Tesla Models CLI Data Gem Project"
date:       2018-06-15 22:56:38 -0400
permalink:  tesla_models_cli_data_gem_project
---


This lab was my first project in my portfolio to test out and showcase skills I learned during my 1.5 month at Flatiron School. In this CLI project I created an application to scrape information about Tesla models listed on https://www.caranddriver.com/tesla. The application consists of two main layers and 2 smaller layers. First, it displays a greeting. Second, it lists all the Tesla models that are listed on the website. Third, it asks for a user to input to learn more about an individual model. Based on the user input, it displays detailed information about an individual model, or displays the list of models again, or asks for a correct input if an invalid input is entered, and ends the application if typed “exit”. The project can be accessed [here](https://github.com/Dillorom/cli-data-gem-assessment-v-000) on Github. 

Initially, I planned to scrape https://www.tesla.com/ , which is the original website for Tesla models. However, the dynamic nature of the application seemed to make it difficult for me to scrape, since I am in a beginning stage of my quest into coding. Therefore, I chose https://www.caranddriver.com/tesla for scraping, which is much easier to scrape. 
Before starting my project, I watched the recorded project walkthroughs twice. The first time when I watched, concepts seemed foreign, and I only focused on details. Watching them second time helped me to understand the bigger picture of what I am about to do. I also peaked through the first walkthrough several times while coding for further reference, because my project structure was similar to the example in the walkthrough.

While working on my project, first I created an outline of my project, where I mapped out my layers. Based on them, I made a gem and I created relative files and folders. Then I worked on dependencies. Executable files in the “bin” folder are responsible for executing codes written in the “lib” folder. So, the executable file must have access to the files in the “lib” folder, and I connected them through “require”. Since I had more than one file in the “lib” folder, my main ruby file that was connected to the “bin” folder had to have access to the rest of the files in the “lib” folder. I also needed access to “nokogiri” and “open-uri” gems for scraping and “pry” for debugging while coding. 

Dependencies set up access to different files and folders. However, they are alone not able to run the application. To execute the application, we need to call a class that contains necessary lines of codes, with a “call” method in the “bin” file. After calling a class in the “bin” folder that has not existed yet, I went to “lib” folder and created a “cli” class that would be responsible for holding basic structure of codes to run the CLI. In the “call” method in my “cli” file, I listed an order of layers of my application that would be responsible for greeting a user, listing all the cars on the webpage with a brief information, and created methods to carry out the actions that asked a user for an input and responded accordingly after an input entered, and ended the application by saying “goodbye”. 

I created a separate class, where I set up attributes of an individual model car (in the attraccessor), initialized an instance of a model, created a class method to scrape the webpage. While scraping, I used a loop to go through each individual model’s page to collect information and create an instance of a model to be added to an array of models. At the end of the model, I called the array to return full list of models. 

Once the model class was ready, I called the model class with a scrape method in my “cli” class in my “call” method. This way my methods in the “cli” class would have access to information that was scraped from the website. 
In my “menu” method in the “cli” class, I handled an exceptional model that did not have relevant information to scrape on the webpage with an “if” statement and specified actions for the application depending on when conditions met or not met. 

Although the project seemed difficult initially, it went smoothly once I got started. I stumbled upon a few obstacles, but I learned through them. For example, while requiring my “cli” file in my main file in the “lib” folder, I keep getting errors, because I was specifying the folder name “lib” before “cli”, which was not needed, since the both files were inside the same folder. I also kept getting errors for displacing the order of methods to call in my “call” method in the “cli” file. I learned that the order of methods is important to pay attention, because they will fill each other with a relevant information to execute. The most difficult thing I face during my project was working with the scrape method to catch an exact information that I was looking for. Depending on the structure of websites, sometimes the process can be complicated, and now I feel proud that I handled the process well in my first CLI gem data project. 
